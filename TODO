Remove any relation to webhelpers or historical Pylons functionality.
Paginate must work standalone.

Add license headers everywhere (MIT).

Provide simple URL generator. Let the user declare their own URL generation function instead.
Like a callback function with the page number as a parameter.

Move the **kwargs of pager into a dictionary parameter pager_linkattr (more explicit)

Move SQLAlchemy code as an extension into paginate.sqlalchemy

Create test with setup/teardown code for paginate.sqlalchemy.SqlalchemyPage (e.g. sqlite)

Perhaps move paginate.ext_sqlalchemy into external modules like paginate_sqlalchemy

Make sure that the CHANGELOG reflects all relevant API changes.

Improve handling of AJAX links. No magical "partial" argument.

Ensure that escaping of ' and " is not causing headaches in make_html_tag.
In [8]: make_html_tag('a', foo=3, bar=123, onclick="$('#bla').doStuff()")
Out[8]: '<a foo="3" bar="123" onclick="$(\'#bla\').doStuff()">'

add support for CouchDB databases (http://guide.couchdb.org/editions/1/de/recipes.html)

Make sure that the docstring are in good shape.

Upload to PyPi

Announce to pylons-discussion mailing list.

Add AJAX tutorial

        onclick (optional)
            This paramter is a string containing optional Javascript code
            that will be used as the 'onclick' action of each pager link.
            It can be used to enhance your pager with AJAX actions loading another 
            page into a DOM object. 

            In this string the variable '$partial_url' will be replaced by
            the URL linking to the desired page with an added 'partial=1'
            parameter (or whatever you set 'partial_param' to).
            In addition the '$page' variable gets replaced by the
            respective page number.

            Note that the URL to the destination page contains a 'partial_param' 
            parameter so that you can distinguish between AJAX requests (just 
            refreshing the paginated area of your page) and full requests (loading 
            the whole new page).

            [Backward compatibility: you can use '%s' instead of '$partial_url']

            jQuery example:
                "$('#my-page-area').load('$partial_url'); return false;"

            Yahoo UI example:
                "YAHOO.util.Connect.asyncRequest('GET','$partial_url',{
                    success:function(o){YAHOO.util.Dom.get('#my-page-area').innerHTML=o.responseText;}
                    },null); return false;"

            scriptaculous example:
                "new Ajax.Updater('#my-page-area', '$partial_url',
                    {asynchronous:true, evalScripts:true}); return false;"

            ExtJS example:
                "Ext.get('#my-page-area').load({url:'$partial_url'}); return false;"
            
            Custom example:
                "my_load_page($page)"

    p.pager(url="/index.php?page=$page", link_attr=dict(onclick="$('target').load('/ding/dong?page=$page'"))

SQLAlchemy tests


#class TestSQLAlchemyCollectionTypes(unittest.TestCase):
#    def setUp(self):
#        try:
#            import sqlalchemy as sa
#            import sqlalchemy.orm as orm
#        except ImportError:
#            raise SkipTest()
#        self.engine = engine = sa.create_engine("sqlite://") # Memory database
#        self.sessionmaker = orm.sessionmaker(bind=engine)
#        self.metadata = metadata = sa.MetaData(bind=engine)
#        self.notes = notes = sa.Table("Notes", metadata,
#            sa.Column("id", sa.Integer, primary_key=True))
#        class Note(object):
#            pass
#        self.Note = Note
#        notes.create()
#        orm.mapper(Note, notes)
#        insert = notes.insert()
#        records = [{"id": x} for x in range(1, 101)]
#        engine.execute(insert, records)
#            
#    def tearDown(self):
#        import sqlalchemy as sa
#        import sqlalchemy.orm as orm
#        orm.clear_mappers()
#        self.notes.drop()
#
#    def test_sqlalchemy_orm(self):
#        session = self.sessionmaker()
#        q = session.query(self.Note).order_by(self.Note.id)
#        page = paginate.Page(q)
#        records = list(page)
#        eq_(records[0].id, 1)
#        eq_(records[-1].id, 20)

